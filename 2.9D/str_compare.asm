compare_strs_si_bx:
    push si                   ; сохраняем все нужные в функции регистры на стеке
    push bx
    push ax

comp:
    mov ah, [bx]              ; напрямую регистры сравнить не получится,
    cmp [si], ah              ; поэтому переносим первый символ в ah
    jne not_equal             ; если символы не совпадают, то выходим из функции

    cmp byte [si], 0          ; в обратном случае сравниваем, является ли символ
    je first_zero             ; символом окончания строки

    inc si                    ; переходим к следующему байту bx и si
    inc bx

    jmp comp                  ; и повторяем

first_zero:
    cmp byte [bx], 0          ; если символ в bx != 0, то значит, что строки
    jne not_equal             ; не равны, поэтому переходим в not_equal

    mov cx, 1                 ; в обратном случае строки равны, значит cx = 1

    pop si                    ; поэтому восстанавливаем значения регистров
    pop bx
    pop ax

    ret                       ; и выходим из функции

not_equal:
    mov cx, 0                 ; не равны, значит cx = 0

    pop si                    ; восстанавливаем значения регистров
    pop bx
    pop ax

    ret                       ; и выходим из функции
